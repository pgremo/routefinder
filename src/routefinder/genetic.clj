(ns routefinder.genetic
  (:use [routefinder.core])
  (:use [clojure.math.numeric-tower :only [abs]])
  (:use [clojure.string :only [join]]))

(def target
  "Hello Clojure World!")

(defn distance
  "Determines the fitness of a given subject based on the
  distance between it and the target"
  [subject]
  (reduce + (map (comp abs compare) subject target)))

(def fitness
  (memoize distance))

(defn breed
  "Decides whether to breed cleanly or with a mutation. Also provides a random
  position for breeding if not provided"
  [s1]
  (if (< 0 (rand-int 2))
    s1
    (let [size (count s1)]
      (swap s1 (rand-int size) (rand-int size)))))

(defn create-initial-sample
  "Creates a subjects of the given length composed of random elements"
  []
  (let [target-seq (seq target)]
    (repeatedly 1000 #(shuffle target-seq))))

(defn tourny-select-subject
  "Takes a list of subjects, selects two at random, and returns the one with
  best fitness"
  [list]
  (min-key fitness (rand-nth list) (rand-nth list)))

(defn select-subjects
  "The selected group is generated by taking the best 10 subjects (elitism),
  then repeated calling tourny-select on the sample to generate 90 more."
  [sample]
  (concat (take 10 sample) (repeatedly 90 #(tourny-select-subject sample))))

(defn breed-subjects
  "Generates the solution set by repeatedly selecting two subjects
  (at random) and breeding them"
  [subjects]
  (map breed (repeatedly 1000 #(rand-nth subjects))))

(defn solve
  []
  (->>
    (create-initial-sample)
    (iterate (comp (partial sort-by fitness) breed-subjects select-subjects))
    (map first)))

(defn -main
  []
  (println (->> (solve) (take 100) (last))))